/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 48);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/* no static exports found */
/*!*************************!*\
  !*** external "vendor" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = vendor;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInZlbmRvclwiP2I5NDAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB2ZW5kb3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ2ZW5kb3JcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/* no static exports found */
/* all exports used */
/*!*************************************************************************!*\
  !*** delegated ./node_modules/react/react.js from dll-reference vendor ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(28);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcj85NDE5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDI4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvclxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 2:
/* no static exports found */
/* all exports used */
/*!*****************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference vendor ***!
  \*****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(46);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3I/OTkyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg0Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 3:
/* exports provided: css, keyframes, injectGlobal, ThemeProvider, withTheme, default */
/* all exports used */
/*!*********************************************************************************************************!*\
  !*** delegated ./node_modules/styled-components/dist/styled-components.es.js from dll-reference vendor ***!
  \*********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(81);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5lcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yP2FlNGUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmVzLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),

/***/ 31:
/* no static exports found */
/* all exports used */
/*!***************************************!*\
  !*** ./src/fcc/calculator/styles.jsx ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Button = exports.Result = exports.Formula = exports.Screen = exports.Body = undefined;\n\nvar _templateObject = _taggedTemplateLiteral(['\\n  body {\\n    font-family: \\'Open Sans\\', sans-serif;\\n    background: #555555;\\n    text-align: center;\\n  }\\n'], ['\\n  body {\\n    font-family: \\'Open Sans\\', sans-serif;\\n    background: #555555;\\n    text-align: center;\\n  }\\n']),\n    _templateObject2 = _taggedTemplateLiteral(['\\n  position: relative;\\n  display: inline-block;\\n  max-width: 440px;\\n  min-width: 240px;\\n  width: 95%;\\n  background: #ECEFF1;\\n  margin-top: 5%;\\n  box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\\n  border-radius: 5px;\\n  padding-bottom: 10px;\\n'], ['\\n  position: relative;\\n  display: inline-block;\\n  max-width: 440px;\\n  min-width: 240px;\\n  width: 95%;\\n  background: #ECEFF1;\\n  margin-top: 5%;\\n  box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\\n  border-radius: 5px;\\n  padding-bottom: 10px;\\n']),\n    _templateObject3 = _taggedTemplateLiteral(['\\n  display: block;\\n  position: relative;\\n  margin: 15px;\\n  height: 96px;\\n  box-shadow: 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  border-radius: 5px;\\n  background: #009688;\\n  font-weight: bold;\\n  color: white;\\n'], ['\\n  display: block;\\n  position: relative;\\n  margin: 15px;\\n  height: 96px;\\n  box-shadow: 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  border-radius: 5px;\\n  background: #009688;\\n  font-weight: bold;\\n  color: white;\\n']),\n    _templateObject4 = _taggedTemplateLiteral(['\\n  height: 40%;\\n  padding: 10px;\\n  text-align: left;\\n  font-size: 140%;\\n  width: 100%;\\n  box-sizing: border-box;\\n'], ['\\n  height: 40%;\\n  padding: 10px;\\n  text-align: left;\\n  font-size: 140%;\\n  width: 100%;\\n  box-sizing: border-box;\\n']),\n    _templateObject5 = _taggedTemplateLiteral(['\\n  height: 60%;\\n  padding: 10px;\\n  padding-top: 5px;\\n  text-align: right;\\n  font-size: 200%;\\n  width: 100%;\\n  box-sizing: border-box;\\n'], ['\\n  height: 60%;\\n  padding: 10px;\\n  padding-top: 5px;\\n  text-align: right;\\n  font-size: 200%;\\n  width: 100%;\\n  box-sizing: border-box;\\n']),\n    _templateObject6 = _taggedTemplateLiteral(['\\n  display: inline-block;\\n  position: relative;\\n\\n  width: ', ';\\n  height: 70px;\\n  line-height: 70px;\\n  margin: 5px;\\n\\n  text-align: center;\\n  font-size: 48px;\\n\\n  box-shadow: 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  border-radius: 4px;\\n  background: #FFFFFF;\\n\\n  -webkit-touch-callout: none;\\n  user-select: none;\\n\\n  cursor: pointer;\\n\\n  &:hover {\\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\\n  }\\n\\n  &:active {\\n    box-shadow: inset 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  }\\n'], ['\\n  display: inline-block;\\n  position: relative;\\n\\n  width: ', ';\\n  height: 70px;\\n  line-height: 70px;\\n  margin: 5px;\\n\\n  text-align: center;\\n  font-size: 48px;\\n\\n  box-shadow: 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  border-radius: 4px;\\n  background: #FFFFFF;\\n\\n  -webkit-touch-callout: none;\\n  user-select: none;\\n\\n  cursor: pointer;\\n\\n  &:hover {\\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\\n  }\\n\\n  &:active {\\n    box-shadow: inset 0 1px 3px rgba(0,0,0,0.16), 0 1px 3px rgba(0,0,0,0.23);\\n  }\\n']);\n\nvar _styledComponents = __webpack_require__(/*! styled-components */ 3);\n\nvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); } /******************************************************************************/\n/* file: styles.jsx                                                           */\n/* author: Jeremie van der Sande                                              */\n/******************************************************************************/\n/* Styles for the Calculator app                                              */\n/******************************************************************************/\n\n/* 'styled-components' is used to keep the best of both the React and CSS\r\n * worlds                                                                     */\n\n\n/* Small tweak to the base DOM behavior & looks                               */\n(0, _styledComponents.injectGlobal)(_templateObject);\n\n/* Body: <div> element containing the calculator. It is centered on the page\r\n *       thanks to 'inline-block', will only exceed the screen width if the\r\n *       screen is smaller than 240px, and will expand to a max of 440px      */\nvar Body = exports.Body = _styledComponents2.default.div(_templateObject2);\n\n/* Screen: <div> element for the screen of the calculator. Green background,\r\n * with a discrete shadow. Fills the entire width                             */\nvar Screen = exports.Screen = _styledComponents2.default.div(_templateObject3);\n\n/* Formula: <div> element to hold the formula. Positionned at the top of the\r\n            Screen element                                                    */\nvar Formula = exports.Formula = _styledComponents2.default.div(_templateObject4);\n\n/* Result: <div> element to hold the result. Positionned at the bottom of the\r\n           Screen element, text aligned right                                 */\nvar Result = exports.Result = _styledComponents2.default.div(_templateObject5);\n\n/* Button: <div> element representing a button of the calculator. Can either\r\n           take a fourth or half of the width, depending on the 'double' prop.\r\n           Discrete shadow like the screen, serving as a hover & press hint   */\nvar Button = exports.Button = _styledComponents2.default.div(_templateObject6, function (props) {\n  return props.double ? 'calc(50% - 20px)' : 'calc(25% - 15px)';\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2ZjYy9jYWxjdWxhdG9yL3N0eWxlcy5qc3g/MmUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiBmaWxlOiBzdHlsZXMuanN4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiBhdXRob3I6IEplcmVtaWUgdmFuIGRlciBTYW5kZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiBTdHlsZXMgZm9yIHRoZSBDYWxjdWxhdG9yIGFwcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyogJ3N0eWxlZC1jb21wb25lbnRzJyBpcyB1c2VkIHRvIGtlZXAgdGhlIGJlc3Qgb2YgYm90aCB0aGUgUmVhY3QgYW5kIENTU1xyXG4gKiB3b3JsZHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5pbXBvcnQgc3R5bGVkLCB7aW5qZWN0R2xvYmFsfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cydcclxuXHJcblxyXG4vKiBTbWFsbCB0d2VhayB0byB0aGUgYmFzZSBET00gYmVoYXZpb3IgJiBsb29rcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5pbmplY3RHbG9iYWxgXHJcbiAgYm9keSB7XHJcbiAgICBmb250LWZhbWlseTogJ09wZW4gU2FucycsIHNhbnMtc2VyaWY7XHJcbiAgICBiYWNrZ3JvdW5kOiAjNTU1NTU1O1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIH1cclxuYFxyXG5cclxuLyogQm9keTogPGRpdj4gZWxlbWVudCBjb250YWluaW5nIHRoZSBjYWxjdWxhdG9yLiBJdCBpcyBjZW50ZXJlZCBvbiB0aGUgcGFnZVxyXG4gKiAgICAgICB0aGFua3MgdG8gJ2lubGluZS1ibG9jaycsIHdpbGwgb25seSBleGNlZWQgdGhlIHNjcmVlbiB3aWR0aCBpZiB0aGVcclxuICogICAgICAgc2NyZWVuIGlzIHNtYWxsZXIgdGhhbiAyNDBweCwgYW5kIHdpbGwgZXhwYW5kIHRvIGEgbWF4IG9mIDQ0MHB4ICAgICAgKi9cclxuZXhwb3J0IGNvbnN0IEJvZHkgPSBzdHlsZWQuZGl2YFxyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgbWF4LXdpZHRoOiA0NDBweDtcclxuICBtaW4td2lkdGg6IDI0MHB4O1xyXG4gIHdpZHRoOiA5NSU7XHJcbiAgYmFja2dyb3VuZDogI0VDRUZGMTtcclxuICBtYXJnaW4tdG9wOiA1JTtcclxuICBib3gtc2hhZG93OiAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjE2KSwgMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4yMyk7XHJcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gIHBhZGRpbmctYm90dG9tOiAxMHB4O1xyXG5gXHJcblxyXG4vKiBTY3JlZW46IDxkaXY+IGVsZW1lbnQgZm9yIHRoZSBzY3JlZW4gb2YgdGhlIGNhbGN1bGF0b3IuIEdyZWVuIGJhY2tncm91bmQsXHJcbiAqIHdpdGggYSBkaXNjcmV0ZSBzaGFkb3cuIEZpbGxzIHRoZSBlbnRpcmUgd2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbmV4cG9ydCBjb25zdCBTY3JlZW4gPSBzdHlsZWQuZGl2YFxyXG4gIGRpc3BsYXk6IGJsb2NrO1xyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICBtYXJnaW46IDE1cHg7XHJcbiAgaGVpZ2h0OiA5NnB4O1xyXG4gIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjIzKTtcclxuICBib3JkZXItcmFkaXVzOiA1cHg7XHJcbiAgYmFja2dyb3VuZDogIzAwOTY4ODtcclxuICBmb250LXdlaWdodDogYm9sZDtcclxuICBjb2xvcjogd2hpdGU7XHJcbmBcclxuXHJcbi8qIEZvcm11bGE6IDxkaXY+IGVsZW1lbnQgdG8gaG9sZCB0aGUgZm9ybXVsYS4gUG9zaXRpb25uZWQgYXQgdGhlIHRvcCBvZiB0aGVcclxuICAgICAgICAgICAgU2NyZWVuIGVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuZXhwb3J0IGNvbnN0IEZvcm11bGEgPSBzdHlsZWQuZGl2YFxyXG4gIGhlaWdodDogNDAlO1xyXG4gIHBhZGRpbmc6IDEwcHg7XHJcbiAgdGV4dC1hbGlnbjogbGVmdDtcclxuICBmb250LXNpemU6IDE0MCU7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuYFxyXG5cclxuLyogUmVzdWx0OiA8ZGl2PiBlbGVtZW50IHRvIGhvbGQgdGhlIHJlc3VsdC4gUG9zaXRpb25uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGVcclxuICAgICAgICAgICBTY3JlZW4gZWxlbWVudCwgdGV4dCBhbGlnbmVkIHJpZ2h0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuZXhwb3J0IGNvbnN0IFJlc3VsdCA9IHN0eWxlZC5kaXZgXHJcbiAgaGVpZ2h0OiA2MCU7XHJcbiAgcGFkZGluZzogMTBweDtcclxuICBwYWRkaW5nLXRvcDogNXB4O1xyXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xyXG4gIGZvbnQtc2l6ZTogMjAwJTtcclxuICB3aWR0aDogMTAwJTtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gXHJcblxyXG4vKiBCdXR0b246IDxkaXY+IGVsZW1lbnQgcmVwcmVzZW50aW5nIGEgYnV0dG9uIG9mIHRoZSBjYWxjdWxhdG9yLiBDYW4gZWl0aGVyXHJcbiAgICAgICAgICAgdGFrZSBhIGZvdXJ0aCBvciBoYWxmIG9mIHRoZSB3aWR0aCwgZGVwZW5kaW5nIG9uIHRoZSAnZG91YmxlJyBwcm9wLlxyXG4gICAgICAgICAgIERpc2NyZXRlIHNoYWRvdyBsaWtlIHRoZSBzY3JlZW4sIHNlcnZpbmcgYXMgYSBob3ZlciAmIHByZXNzIGhpbnQgICAqL1xyXG5leHBvcnQgY29uc3QgQnV0dG9uID0gc3R5bGVkLmRpdmBcclxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG5cclxuICB3aWR0aDogJHtwcm9wcyA9PiBwcm9wcy5kb3VibGU/ICdjYWxjKDUwJSAtIDIwcHgpJzonY2FsYygyNSUgLSAxNXB4KSd9O1xyXG4gIGhlaWdodDogNzBweDtcclxuICBsaW5lLWhlaWdodDogNzBweDtcclxuICBtYXJnaW46IDVweDtcclxuXHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIGZvbnQtc2l6ZTogNDhweDtcclxuXHJcbiAgYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwwLDAsMC4xNiksIDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuMjMpO1xyXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcclxuICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xyXG5cclxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XHJcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcblxyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxuXHJcbiAgJjpob3ZlciB7XHJcbiAgICBib3gtc2hhZG93OiAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjE2KSwgMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4yMyk7XHJcbiAgfVxyXG5cclxuICAmOmFjdGl2ZSB7XHJcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggM3B4IHJnYmEoMCwwLDAsMC4yMyk7XHJcbiAgfVxyXG5gXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZmNjL2NhbGN1bGF0b3Ivc3R5bGVzLmpzeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFTQTtBQUNBOzs7OztBQVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFPQTs7O0FBR0E7QUFDQTtBQVlBOztBQUVBO0FBQ0E7QUFXQTs7QUFFQTtBQUNBO0FBUUE7O0FBRUE7QUFDQTtBQVNBOzs7QUFHQTtBQUlBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),

/***/ 48:
/* no static exports found */
/* all exports used */
/*!**************************************!*\
  !*** ./src/fcc/calculator/index.jsx ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(/*! react-dom */ 2);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _styles = __webpack_require__(/*! ./styles */ 31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /******************************************************************************/\n/* file: index.jsx                                                            */\n/* author: Jeremie van der Sande                                              */\n/******************************************************************************/\n/* Entry point and main component for the Calculator project                  */\n/*    The solution chosen was to rely on RegEx for the computation, and on a  */\n/*    Finite State Machine for handling key presses                           */\n/******************************************************************************/\n\n/* Import React as our main framework                                         */\n\n\n/* Import React DOM to inject our components                                  */\n\n\n/* Import the custom styles from 'styles.jsx'.\n * 'styled-components' is used to keep the best of both the React and CSS\n * worlds   */\n\n\n/* Create an enum of human-readable states for our FSM                        */\nvar ANYTHING = 0,\n    DIGIT = 1,\n    OPERATOR = 2,\n    NOT_DOT_DIGIT = 3,\n    NOT_DOT_ANYTHING = 4;\n\n/* Calculator is the main component for the project. It renders the complete\n * page and handles the calculator's state                                    */\n\nvar Calculator = function (_Component) {\n  _inherits(Calculator, _Component);\n\n  function Calculator() {\n    _classCallCheck(this, Calculator);\n\n    /* React state, holding the currently input formula, and the last result  */\n    var _this = _possibleConstructorReturn(this, (Calculator.__proto__ || Object.getPrototypeOf(Calculator)).call(this));\n\n    _this.onButtonClick = function (button) {\n      /* If the button is AC or DEL, then we need to reset or rewind or FSM     */\n      switch (button) {\n        case 'AC':\n          /* If the button is AC, we completely reset the FSM. The next status is\n           * digit only, and the formula and result are cleared                 */\n          _this.status = DIGIT;\n\n          _this.setState({ formula: '', result: '' });\n          break;\n        case 'DEL':\n          /* If the DEL button is pressed, then we remove one character from the\n           * formula and get the corresponding status                           */\n          var formula = _this.state.formula;\n          formula = formula.substr(0, formula.length - 1);\n\n          _this.status = _this.getPreviousStatus(formula);\n\n          _this.setState({ formula: formula });\n          break;\n        default:\n          /* If another button is pressed, then we compute the next status      */\n          _this.getNextStatus(button);\n          break;\n      }\n    };\n\n    _this.state = {\n      formula: '',\n      result: ''\n\n      /* Our FSM's state                                                        */\n    };_this.status = DIGIT;\n\n    /* A list of button to diwplay on the calculator                          */\n    _this.buttons = [{ name: 'clear', value: 'AC', double: true }, { name: 'delete', value: 'DEL', double: true }, { name: 'c7', value: '7' }, { name: 'c8', value: '8' }, { name: 'c9', value: '9' }, { name: 'plus', value: '+' }, { name: 'c4', value: '4' }, { name: 'c5', value: '5' }, { name: 'c6', value: '6' }, { name: 'minus', value: '-' }, { name: 'c1', value: '1' }, { name: 'c2', value: '2' }, { name: 'c3', value: '3' }, { name: 'multiply', value: 'x' }, { name: 'dot', value: '.' }, { name: 'c0', value: '0' }, { name: 'equal', value: '=' }, { name: 'divide', value: '/' }];\n    return _this;\n  }\n\n  /* The compute function takes a literal formula and extracts the result     */\n\n\n  _createClass(Calculator, [{\n    key: 'compute',\n    value: function compute() {\n      /* Temporary copy of 'entry' to watch for a stable state                  */\n      var temp = void 0;\n\n      /* Copy of the formula to parse                                           */\n      var entry = this.state.formula;\n\n      /* The first step is to take care of all multiplications and divisions,\n       * since we do not have parentheses                                       */\n      do {\n        /* Make a copy of the entry, before modifying it                        */\n        temp = entry;\n      }\n      /* Exit the loop once the modified entry is the same as the saved entry   */\n      while (temp != (entry = entry.replace(\n      /* Look for a multiplication or division of two numbers                 */\n      /(-?[0-9.]+)([x/])(-?[0-9.]+)/,\n      /* Get the a and b operands, and apply the correct operation.           */\n      function (f, a, op, b) {\n        a = parseFloat(a);\n        b = parseFloat(b);\n\n        /* Replace the operation with its result                              */\n        return op == 'x' ? a * b : a / b;\n      })));\n\n      /* When we reach this point, there is no more multiplication or division  */\n\n      /* We can now look for additions and substractions                        */\n      do {\n        /* Make a copy of the entry, before modifying it                        */\n        temp = entry;\n      }\n      /* Exit the loop once the modified entry is the same as the saved entry   */\n      while (temp != (entry = entry.replace(\n      /* Look for an addition or substraction of two numbers                  */\n      /(-?[0-9.]+)([-+])(-?[0-9.]+)/,\n      /* Get the a and b operands, and apply the correct operation.           */\n      function (f, a, op, b) {\n        a = parseFloat(a);\n        b = parseFloat(b);\n\n        /* Replace the operation with its result                              */\n        return op == '+' ? a + b : a - b;\n      })));\n\n      /* Return the final result, rounded at 10 digits                          */\n      return Math.round(entry * Math.pow(10, 10)) / Math.pow(10, 10) + '';\n    }\n\n    /* Observe the end of the literal operation to determine what can be input\n     * next, in case of delete                                                  */\n\n  }, {\n    key: 'getPreviousStatus',\n    value: function getPreviousStatus(f) {\n      /* Get everything after the last operator                                 */\n      f = f.split(/[+/x-]/g).pop();\n\n      /* Get the last character                                                 */\n      var c = f[f.length - 1] || '';\n\n      /* If there is nothing after the last operator then only a digit can be\n       * input                                                                  */\n      if (f.length < 1) return DIGIT;\n\n      /* If the last character is a dot, only a digit can be input, and no more\n       * dots                                                                   */\n      if (c == '.') return NOT_DOT_DIGIT;\n\n      /* If there is a dot in the last number, then no more dots                */\n      if (f.indexOf('.') > -1) return NOT_DOT_ANYTHING;\n\n      /* Otherwise, anything can be input                                       */\n      return ANYTHING;\n    }\n\n    /* Compute next status based on the clicked button                          */\n\n  }, {\n    key: 'getNextStatus',\n    value: function getNextStatus(b) {\n      var _state = this.state,\n          formula = _state.formula,\n          result = _state.result;\n\n      /* Since we are in a Finite State Machine, the next status is computed based\n       * on the current status, and the current input. We start by a switch on the\n       * current status                                                         */\n\n      switch (this.status) {\n        /* If anything can be input, then we add it to the formula and act from\n         * there. In case of 'NOT_DOT', then we simply ignore dot inputs        */\n        case NOT_DOT_ANYTHING:\n          if (b == '.') break;\n        case ANYTHING:\n          /* Add the new input to the formula                                   */\n          formula += b;\n\n          /* Find the next status based on the input                            */\n\n          /* If the input is an operator, the we expect a digit next            */\n          if (b.match(/[x+/-]/)) {\n            this.status = DIGIT;\n          }\n          /* If the input is a dot, then we expect a digit and no more dots     */\n          else if (b == '.') {\n              this.status = NOT_DOT_DIGIT;\n            }\n            /* If the input is the equal sign, then we compute the formula and put\n             * it as the last result. We then expect an operator to continue the\n             * computation                                                        */\n            else if (b == '=') {\n                result = this.compute();\n                formula = '';\n                this.status = OPERATOR;\n              }\n          break;\n\n        /* If only a digit can be input, then we only add to the formula if the\n         * input is a digit. If the input is an operator, we replace the last\n         * operator. If the input is a minus sign, we add it as sign if possible.\n         * In case of 'NOT_DOT', then we simply ignore dot inputs               */\n        case NOT_DOT_DIGIT:\n          if (b == '.') break;\n        case DIGIT:\n          /* If the input is a strict positive number, we add it to the formula */\n          if (b.match(/[1-9]/)) {\n            formula += b;\n\n            /* Make sure to respect the 'NOT_DOT' situation                     */\n            this.status = this.status == DIGIT ? ANYTHING : NOT_DOT_ANYTHING;\n          }\n          /* If the input is zero and the preceeding character is not the\n           * division operator, we add it to the formula                        */\n          else if (b == '0' && formula[formula.length - 1] != '/') {\n              formula += b;\n\n              /* Make sure to respect the 'NOT_DOT' situation                     */\n              this.status = this.status == DIGIT ? ANYTHING : NOT_DOT_ANYTHING;\n            }\n            /* If the input is an operator other than minus, then we replace the\n             * last operator                                                      */\n            else if (b.match(/[x+/]/)) {\n                formula = formula.substr(0, formula.length - 1) + b;\n              }\n              /* If the input is a minus, and we can add the minus as sign, the we add\n               * it to the formula                                                  */\n              else if (b == '-' && this.canAddMinus(formula)) {\n                  formula += b;\n                }\n          break;\n\n        /* If we are waiting for only an operator, then it means the formula is\n         * empty and we are expecting to work with the previous result          */\n        case OPERATOR:\n          /* If the input is an operator, then we prepare the next formula      */\n          if (b.match(/[x+/-]/)) {\n            /* We add the operator to the previous result                       */\n            formula = result + b;\n\n            /* We clear the result                                              */\n            result = '';\n\n            /* We now expect a digit                                            */\n            this.status = DIGIT;\n          }\n          break;\n      }\n\n      /* Finally, we update our React state to display the new formula and/or\n       * result                                                                 */\n      this.setState({ formula: formula, result: result });\n    }\n\n    /* Check if it is possible to input a minus as sign, not as operator        */\n\n  }, {\n    key: 'canAddMinus',\n    value: function canAddMinus(f) {\n      /* Get everything after the last number                                   */\n      f = f.split(/[0-9.]+/g).pop();\n\n      /* If there is less than 2 characters after the last number, we can add\n       * minus as sign (max allowed is one operator before the minus sign)      */\n      return f.length < 2;\n    }\n\n    /* Resolve the next state of the app after a button press                   */\n\n  }, {\n    key: 'render',\n\n\n    /* Render the current state of the calculator                               */\n    value: function render() {\n      var _this2 = this;\n\n      return _react2.default.createElement(\n        _styles.Body,\n        null,\n        _react2.default.createElement(\n          _styles.Screen,\n          null,\n          _react2.default.createElement(\n            _styles.Formula,\n            null,\n            this.state.formula.replace(/(.)([+/x-])/g, function (e, m1, m2) {\n              return m1 + ' ' + m2 + ' ';\n            })\n          ),\n          _react2.default.createElement(\n            _styles.Result,\n            null,\n            this.state.result\n          )\n        ),\n        this.buttons.map(function (b) {\n          return _react2.default.createElement(\n            _styles.Button,\n            _extends({}, b, { onClick: function onClick() {\n                return _this2.onButtonClick(b.value);\n              } }),\n            b.value\n          );\n        })\n      );\n    }\n  }]);\n\n  return Calculator;\n}(_react.Component);\n\n/* The <div id='root'> element of our HTML will render our components         */\n\n\nvar target = document.getElementById('root');\n\n/* Render the Calculator project                                              */\n_reactDom2.default.render(_react2.default.createElement(Calculator, null), target);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2ZjYy9jYWxjdWxhdG9yL2luZGV4LmpzeD81YmE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBmaWxlOiBpbmRleC5qc3ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogYXV0aG9yOiBKZXJlbWllIHZhbiBkZXIgU2FuZGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBFbnRyeSBwb2ludCBhbmQgbWFpbiBjb21wb25lbnQgZm9yIHRoZSBDYWxjdWxhdG9yIHByb2plY3QgICAgICAgICAgICAgICAgICAqL1xuLyogICAgVGhlIHNvbHV0aW9uIGNob3NlbiB3YXMgdG8gcmVseSBvbiBSZWdFeCBmb3IgdGhlIGNvbXB1dGF0aW9uLCBhbmQgb24gYSAgKi9cbi8qICAgIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIGZvciBoYW5kbGluZyBrZXkgcHJlc3NlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbi8qIEltcG9ydCBSZWFjdCBhcyBvdXIgbWFpbiBmcmFtZXdvcmsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0J1xuXG4vKiBJbXBvcnQgUmVhY3QgRE9NIHRvIGluamVjdCBvdXIgY29tcG9uZW50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcblxuLyogSW1wb3J0IHRoZSBjdXN0b20gc3R5bGVzIGZyb20gJ3N0eWxlcy5qc3gnLlxuICogJ3N0eWxlZC1jb21wb25lbnRzJyBpcyB1c2VkIHRvIGtlZXAgdGhlIGJlc3Qgb2YgYm90aCB0aGUgUmVhY3QgYW5kIENTU1xuICogd29ybGRzICAgKi9cbmltcG9ydCB7XG4gIEJvZHksIFNjcmVlbixcbiAgRm9ybXVsYSwgUmVzdWx0LFxuICBCdXR0b25cbn0gZnJvbSAnLi9zdHlsZXMnXG5cblxuLyogQ3JlYXRlIGFuIGVudW0gb2YgaHVtYW4tcmVhZGFibGUgc3RhdGVzIGZvciBvdXIgRlNNICAgICAgICAgICAgICAgICAgICAgICAgKi9cbmNvbnN0IFtBTllUSElORywgRElHSVQsIE9QRVJBVE9SLCBOT1RfRE9UX0RJR0lULCBOT1RfRE9UX0FOWVRISU5HXSA9IFswLDEsMiwzLDRdXG5cbi8qIENhbGN1bGF0b3IgaXMgdGhlIG1haW4gY29tcG9uZW50IGZvciB0aGUgcHJvamVjdC4gSXQgcmVuZGVycyB0aGUgY29tcGxldGVcbiAqIHBhZ2UgYW5kIGhhbmRsZXMgdGhlIGNhbGN1bGF0b3IncyBzdGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5jbGFzcyBDYWxjdWxhdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgLyogUmVhY3Qgc3RhdGUsIGhvbGRpbmcgdGhlIGN1cnJlbnRseSBpbnB1dCBmb3JtdWxhLCBhbmQgdGhlIGxhc3QgcmVzdWx0ICAqL1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmb3JtdWxhOiAnJyxcbiAgICAgIHJlc3VsdDogJydcbiAgICB9XG5cbiAgICAvKiBPdXIgRlNNJ3Mgc3RhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdGhpcy5zdGF0dXMgPSBESUdJVFxuXG4gICAgLyogQSBsaXN0IG9mIGJ1dHRvbiB0byBkaXdwbGF5IG9uIHRoZSBjYWxjdWxhdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIHRoaXMuYnV0dG9ucyA9IFtcbiAgICAgIHsgbmFtZTogJ2NsZWFyJywgIHZhbHVlOiAnQUMnLCBkb3VibGU6IHRydWUgIH0sXG4gICAgICB7IG5hbWU6ICdkZWxldGUnLCAgdmFsdWU6ICdERUwnLCBkb3VibGU6IHRydWUgIH0sXG5cbiAgICAgIHsgbmFtZTogJ2M3JywgIHZhbHVlOiAnNycgIH0sXG4gICAgICB7IG5hbWU6ICdjOCcsICB2YWx1ZTogJzgnICB9LFxuICAgICAgeyBuYW1lOiAnYzknLCAgdmFsdWU6ICc5JyAgfSxcbiAgICAgIHsgbmFtZTogJ3BsdXMnLCAgdmFsdWU6ICcrJyAgfSxcblxuICAgICAgeyBuYW1lOiAnYzQnLCAgdmFsdWU6ICc0JyAgfSxcbiAgICAgIHsgbmFtZTogJ2M1JywgIHZhbHVlOiAnNScgIH0sXG4gICAgICB7IG5hbWU6ICdjNicsICB2YWx1ZTogJzYnICB9LFxuICAgICAgeyBuYW1lOiAnbWludXMnLCAgdmFsdWU6ICctJyAgfSxcblxuICAgICAgeyBuYW1lOiAnYzEnLCAgdmFsdWU6ICcxJyAgfSxcbiAgICAgIHsgbmFtZTogJ2MyJywgIHZhbHVlOiAnMicgIH0sXG4gICAgICB7IG5hbWU6ICdjMycsICB2YWx1ZTogJzMnICB9LFxuICAgICAgeyBuYW1lOiAnbXVsdGlwbHknLCAgdmFsdWU6ICd4JyAgfSxcblxuICAgICAgeyBuYW1lOiAnZG90JywgIHZhbHVlOiAnLicgIH0sXG4gICAgICB7IG5hbWU6ICdjMCcsICB2YWx1ZTogJzAnICB9LFxuICAgICAgeyBuYW1lOiAnZXF1YWwnLCAgdmFsdWU6ICc9JyAgfSxcbiAgICAgIHsgbmFtZTogJ2RpdmlkZScsICB2YWx1ZTogJy8nICB9LFxuICAgIF1cbiAgfVxuXG5cbiAgLyogVGhlIGNvbXB1dGUgZnVuY3Rpb24gdGFrZXMgYSBsaXRlcmFsIGZvcm11bGEgYW5kIGV4dHJhY3RzIHRoZSByZXN1bHQgICAgICovXG4gIGNvbXB1dGUoKSB7XG4gICAgLyogVGVtcG9yYXJ5IGNvcHkgb2YgJ2VudHJ5JyB0byB3YXRjaCBmb3IgYSBzdGFibGUgc3RhdGUgICAgICAgICAgICAgICAgICAqL1xuICAgIGxldCB0ZW1wXG5cbiAgICAvKiBDb3B5IG9mIHRoZSBmb3JtdWxhIHRvIHBhcnNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgbGV0IGVudHJ5ID0gdGhpcy5zdGF0ZS5mb3JtdWxhXG5cbiAgICAvKiBUaGUgZmlyc3Qgc3RlcCBpcyB0byB0YWtlIGNhcmUgb2YgYWxsIG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zLFxuICAgICAqIHNpbmNlIHdlIGRvIG5vdCBoYXZlIHBhcmVudGhlc2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKiBNYWtlIGEgY29weSBvZiB0aGUgZW50cnksIGJlZm9yZSBtb2RpZnlpbmcgaXQgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgdGVtcCA9IGVudHJ5XG4gICAgfVxuICAgIC8qIEV4aXQgdGhlIGxvb3Agb25jZSB0aGUgbW9kaWZpZWQgZW50cnkgaXMgdGhlIHNhbWUgYXMgdGhlIHNhdmVkIGVudHJ5ICAgKi9cbiAgICB3aGlsZSh0ZW1wICE9IChlbnRyeSA9IGVudHJ5LnJlcGxhY2UoXG4gICAgICAvKiBMb29rIGZvciBhIG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uIG9mIHR3byBudW1iZXJzICAgICAgICAgICAgICAgICAqL1xuICAgICAgLygtP1swLTkuXSspKFt4L10pKC0/WzAtOS5dKykvLFxuICAgICAgLyogR2V0IHRoZSBhIGFuZCBiIG9wZXJhbmRzLCBhbmQgYXBwbHkgdGhlIGNvcnJlY3Qgb3BlcmF0aW9uLiAgICAgICAgICAgKi9cbiAgICAgIChmLCBhLCBvcCwgYikgPT4ge1xuICAgICAgICBhID0gcGFyc2VGbG9hdChhKVxuICAgICAgICBiID0gcGFyc2VGbG9hdChiKVxuXG4gICAgICAgIC8qIFJlcGxhY2UgdGhlIG9wZXJhdGlvbiB3aXRoIGl0cyByZXN1bHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICByZXR1cm4gKG9wPT0neCcpP2EqYjphL2JcbiAgICAgIH1cbiAgICApKSlcblxuXG4gICAgLyogV2hlbiB3ZSByZWFjaCB0aGlzIHBvaW50LCB0aGVyZSBpcyBubyBtb3JlIG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uICAqL1xuXG4gICAgLyogV2UgY2FuIG5vdyBsb29rIGZvciBhZGRpdGlvbnMgYW5kIHN1YnN0cmFjdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBlbnRyeSwgYmVmb3JlIG1vZGlmeWluZyBpdCAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICB0ZW1wID0gZW50cnlcbiAgICB9XG4gICAgLyogRXhpdCB0aGUgbG9vcCBvbmNlIHRoZSBtb2RpZmllZCBlbnRyeSBpcyB0aGUgc2FtZSBhcyB0aGUgc2F2ZWQgZW50cnkgICAqL1xuICAgIHdoaWxlKHRlbXAgIT0gKGVudHJ5ID0gZW50cnkucmVwbGFjZShcbiAgICAgIC8qIExvb2sgZm9yIGFuIGFkZGl0aW9uIG9yIHN1YnN0cmFjdGlvbiBvZiB0d28gbnVtYmVycyAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKC0/WzAtOS5dKykoWy0rXSkoLT9bMC05Ll0rKS8sXG4gICAgICAvKiBHZXQgdGhlIGEgYW5kIGIgb3BlcmFuZHMsIGFuZCBhcHBseSB0aGUgY29ycmVjdCBvcGVyYXRpb24uICAgICAgICAgICAqL1xuICAgICAgKGYsIGEsIG9wLCBiKSA9PiB7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpXG4gICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpXG5cbiAgICAgICAgLyogUmVwbGFjZSB0aGUgb3BlcmF0aW9uIHdpdGggaXRzIHJlc3VsdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgIHJldHVybiAob3A9PScrJyk/YStiOmEtYlxuICAgICAgfVxuICAgICkpKTtcblxuICAgIC8qIFJldHVybiB0aGUgZmluYWwgcmVzdWx0LCByb3VuZGVkIGF0IDEwIGRpZ2l0cyAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICByZXR1cm4gKE1hdGgucm91bmQoZW50cnkgKiBNYXRoLnBvdygxMCwgMTApKSAvIE1hdGgucG93KDEwLCAxMCkpICsgJydcbiAgfVxuXG4gIC8qIE9ic2VydmUgdGhlIGVuZCBvZiB0aGUgbGl0ZXJhbCBvcGVyYXRpb24gdG8gZGV0ZXJtaW5lIHdoYXQgY2FuIGJlIGlucHV0XG4gICAqIG5leHQsIGluIGNhc2Ugb2YgZGVsZXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICBnZXRQcmV2aW91c1N0YXR1cyhmKSB7XG4gICAgLyogR2V0IGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGxhc3Qgb3BlcmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIGYgPSBmLnNwbGl0KC9bKy94LV0vZykucG9wKClcblxuICAgIC8qIEdldCB0aGUgbGFzdCBjaGFyYWN0ZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICBsZXQgYyA9IGZbZi5sZW5ndGggLSAxXSB8fCAnJ1xuXG4gICAgLyogSWYgdGhlcmUgaXMgbm90aGluZyBhZnRlciB0aGUgbGFzdCBvcGVyYXRvciB0aGVuIG9ubHkgYSBkaWdpdCBjYW4gYmVcbiAgICAgKiBpbnB1dCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgaWYoZi5sZW5ndGggPCAxKVxuICAgICAgcmV0dXJuIERJR0lUXG5cbiAgICAvKiBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBkb3QsIG9ubHkgYSBkaWdpdCBjYW4gYmUgaW5wdXQsIGFuZCBubyBtb3JlXG4gICAgICogZG90cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIGlmKGMgPT0gJy4nKVxuICAgICAgcmV0dXJuIE5PVF9ET1RfRElHSVRcblxuICAgIC8qIElmIHRoZXJlIGlzIGEgZG90IGluIHRoZSBsYXN0IG51bWJlciwgdGhlbiBubyBtb3JlIGRvdHMgICAgICAgICAgICAgICAgKi9cbiAgICBpZihmLmluZGV4T2YoJy4nKSA+IC0xKVxuICAgICAgcmV0dXJuIE5PVF9ET1RfQU5ZVEhJTkdcblxuICAgIC8qIE90aGVyd2lzZSwgYW55dGhpbmcgY2FuIGJlIGlucHV0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICByZXR1cm4gQU5ZVEhJTkdcbiAgfVxuXG4gIC8qIENvbXB1dGUgbmV4dCBzdGF0dXMgYmFzZWQgb24gdGhlIGNsaWNrZWQgYnV0dG9uICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICBnZXROZXh0U3RhdHVzKGIpIHtcbiAgICBsZXQge2Zvcm11bGEsIHJlc3VsdH0gPSB0aGlzLnN0YXRlXG5cbiAgICAvKiBTaW5jZSB3ZSBhcmUgaW4gYSBGaW5pdGUgU3RhdGUgTWFjaGluZSwgdGhlIG5leHQgc3RhdHVzIGlzIGNvbXB1dGVkIGJhc2VkXG4gICAgICogb24gdGhlIGN1cnJlbnQgc3RhdHVzLCBhbmQgdGhlIGN1cnJlbnQgaW5wdXQuIFdlIHN0YXJ0IGJ5IGEgc3dpdGNoIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgc3RhdHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICBzd2l0Y2godGhpcy5zdGF0dXMpIHtcbiAgICAgIC8qIElmIGFueXRoaW5nIGNhbiBiZSBpbnB1dCwgdGhlbiB3ZSBhZGQgaXQgdG8gdGhlIGZvcm11bGEgYW5kIGFjdCBmcm9tXG4gICAgICAgKiB0aGVyZS4gSW4gY2FzZSBvZiAnTk9UX0RPVCcsIHRoZW4gd2Ugc2ltcGx5IGlnbm9yZSBkb3QgaW5wdXRzICAgICAgICAqL1xuICAgICAgY2FzZSBOT1RfRE9UX0FOWVRISU5HOiBpZihiID09ICcuJykgYnJlYWtcbiAgICAgIGNhc2UgQU5ZVEhJTkc6XG4gICAgICAgIC8qIEFkZCB0aGUgbmV3IGlucHV0IHRvIHRoZSBmb3JtdWxhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICBmb3JtdWxhICs9IGJcblxuICAgICAgICAvKiBGaW5kIHRoZSBuZXh0IHN0YXR1cyBiYXNlZCBvbiB0aGUgaW5wdXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAvKiBJZiB0aGUgaW5wdXQgaXMgYW4gb3BlcmF0b3IsIHRoZSB3ZSBleHBlY3QgYSBkaWdpdCBuZXh0ICAgICAgICAgICAgKi9cbiAgICAgICAgaWYoYi5tYXRjaCgvW3grLy1dLykpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IERJR0lUXG4gICAgICAgIH1cbiAgICAgICAgLyogSWYgdGhlIGlucHV0IGlzIGEgZG90LCB0aGVuIHdlIGV4cGVjdCBhIGRpZ2l0IGFuZCBubyBtb3JlIGRvdHMgICAgICovXG4gICAgICAgIGVsc2UgaWYoYiA9PSAnLicpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IE5PVF9ET1RfRElHSVRcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiB0aGUgaW5wdXQgaXMgdGhlIGVxdWFsIHNpZ24sIHRoZW4gd2UgY29tcHV0ZSB0aGUgZm9ybXVsYSBhbmQgcHV0XG4gICAgICAgICAqIGl0IGFzIHRoZSBsYXN0IHJlc3VsdC4gV2UgdGhlbiBleHBlY3QgYW4gb3BlcmF0b3IgdG8gY29udGludWUgdGhlXG4gICAgICAgICAqIGNvbXB1dGF0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICBlbHNlIGlmKGIgPT0gJz0nKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb21wdXRlKClcbiAgICAgICAgICBmb3JtdWxhID0gJydcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IE9QRVJBVE9SXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgLyogSWYgb25seSBhIGRpZ2l0IGNhbiBiZSBpbnB1dCwgdGhlbiB3ZSBvbmx5IGFkZCB0byB0aGUgZm9ybXVsYSBpZiB0aGVcbiAgICAgICAqIGlucHV0IGlzIGEgZGlnaXQuIElmIHRoZSBpbnB1dCBpcyBhbiBvcGVyYXRvciwgd2UgcmVwbGFjZSB0aGUgbGFzdFxuICAgICAgICogb3BlcmF0b3IuIElmIHRoZSBpbnB1dCBpcyBhIG1pbnVzIHNpZ24sIHdlIGFkZCBpdCBhcyBzaWduIGlmIHBvc3NpYmxlLlxuICAgICAgICogSW4gY2FzZSBvZiAnTk9UX0RPVCcsIHRoZW4gd2Ugc2ltcGx5IGlnbm9yZSBkb3QgaW5wdXRzICAgICAgICAgICAgICAgKi9cbiAgICAgIGNhc2UgTk9UX0RPVF9ESUdJVDogaWYoYiA9PSAnLicpIGJyZWFrXG4gICAgICBjYXNlIERJR0lUOlxuICAgICAgICAvKiBJZiB0aGUgaW5wdXQgaXMgYSBzdHJpY3QgcG9zaXRpdmUgbnVtYmVyLCB3ZSBhZGQgaXQgdG8gdGhlIGZvcm11bGEgKi9cbiAgICAgICAgaWYoYi5tYXRjaCgvWzEtOV0vKSkge1xuICAgICAgICAgIGZvcm11bGEgKz0gYlxuXG4gICAgICAgICAgLyogTWFrZSBzdXJlIHRvIHJlc3BlY3QgdGhlICdOT1RfRE9UJyBzaXR1YXRpb24gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXMgPT0gRElHSVQgPyBBTllUSElORyA6IE5PVF9ET1RfQU5ZVEhJTkdcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiB0aGUgaW5wdXQgaXMgemVybyBhbmQgdGhlIHByZWNlZWRpbmcgY2hhcmFjdGVyIGlzIG5vdCB0aGVcbiAgICAgICAgICogZGl2aXNpb24gb3BlcmF0b3IsIHdlIGFkZCBpdCB0byB0aGUgZm9ybXVsYSAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgIGVsc2UgaWYoYiA9PSAnMCcgJiYgZm9ybXVsYVtmb3JtdWxhLmxlbmd0aCAtIDFdICE9ICcvJylcbiAgICAgICAge1xuICAgICAgICAgIGZvcm11bGEgKz0gYlxuXG4gICAgICAgICAgLyogTWFrZSBzdXJlIHRvIHJlc3BlY3QgdGhlICdOT1RfRE9UJyBzaXR1YXRpb24gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXMgPT0gRElHSVQgPyBBTllUSElORyA6IE5PVF9ET1RfQU5ZVEhJTkdcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiB0aGUgaW5wdXQgaXMgYW4gb3BlcmF0b3Igb3RoZXIgdGhhbiBtaW51cywgdGhlbiB3ZSByZXBsYWNlIHRoZVxuICAgICAgICAgKiBsYXN0IG9wZXJhdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgZWxzZSBpZihiLm1hdGNoKC9beCsvXS8pKSB7XG4gICAgICAgICAgZm9ybXVsYSA9IGZvcm11bGEuc3Vic3RyKDAsIGZvcm11bGEubGVuZ3RoIC0gMSkgKyBiXG4gICAgICAgIH1cbiAgICAgICAgLyogSWYgdGhlIGlucHV0IGlzIGEgbWludXMsIGFuZCB3ZSBjYW4gYWRkIHRoZSBtaW51cyBhcyBzaWduLCB0aGUgd2UgYWRkXG4gICAgICAgICAqIGl0IHRvIHRoZSBmb3JtdWxhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICBlbHNlIGlmKGIgPT0gJy0nICYmIHRoaXMuY2FuQWRkTWludXMoZm9ybXVsYSkpIHtcbiAgICAgICAgICBmb3JtdWxhICs9IGJcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICAvKiBJZiB3ZSBhcmUgd2FpdGluZyBmb3Igb25seSBhbiBvcGVyYXRvciwgdGhlbiBpdCBtZWFucyB0aGUgZm9ybXVsYSBpc1xuICAgICAgICogZW1wdHkgYW5kIHdlIGFyZSBleHBlY3RpbmcgdG8gd29yayB3aXRoIHRoZSBwcmV2aW91cyByZXN1bHQgICAgICAgICAgKi9cbiAgICAgIGNhc2UgT1BFUkFUT1I6XG4gICAgICAgIC8qIElmIHRoZSBpbnB1dCBpcyBhbiBvcGVyYXRvciwgdGhlbiB3ZSBwcmVwYXJlIHRoZSBuZXh0IGZvcm11bGEgICAgICAqL1xuICAgICAgICBpZihiLm1hdGNoKC9beCsvLV0vKSkge1xuICAgICAgICAgIC8qIFdlIGFkZCB0aGUgb3BlcmF0b3IgdG8gdGhlIHByZXZpb3VzIHJlc3VsdCAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3JtdWxhID0gcmVzdWx0ICsgYlxuXG4gICAgICAgICAgLyogV2UgY2xlYXIgdGhlIHJlc3VsdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIHJlc3VsdCA9ICcnXG5cbiAgICAgICAgICAvKiBXZSBub3cgZXhwZWN0IGEgZGlnaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBESUdJVFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLyogRmluYWxseSwgd2UgdXBkYXRlIG91ciBSZWFjdCBzdGF0ZSB0byBkaXNwbGF5IHRoZSBuZXcgZm9ybXVsYSBhbmQvb3JcbiAgICAgKiByZXN1bHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdGhpcy5zZXRTdGF0ZSh7Zm9ybXVsYSwgcmVzdWx0fSlcbiAgfVxuXG4gIC8qIENoZWNrIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGlucHV0IGEgbWludXMgYXMgc2lnbiwgbm90IGFzIG9wZXJhdG9yICAgICAgICAqL1xuICBjYW5BZGRNaW51cyhmKSB7XG4gICAgLyogR2V0IGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIGYgPSBmLnNwbGl0KC9bMC05Ll0rL2cpLnBvcCgpXG5cbiAgICAvKiBJZiB0aGVyZSBpcyBsZXNzIHRoYW4gMiBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBsYXN0IG51bWJlciwgd2UgY2FuIGFkZFxuICAgICAqIG1pbnVzIGFzIHNpZ24gKG1heCBhbGxvd2VkIGlzIG9uZSBvcGVyYXRvciBiZWZvcmUgdGhlIG1pbnVzIHNpZ24pICAgICAgKi9cbiAgICByZXR1cm4gZi5sZW5ndGggPCAyXG4gIH1cblxuICAvKiBSZXNvbHZlIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSBhcHAgYWZ0ZXIgYSBidXR0b24gcHJlc3MgICAgICAgICAgICAgICAgICAgKi9cbiAgb25CdXR0b25DbGljayA9IChidXR0b24pID0+IHtcbiAgICAvKiBJZiB0aGUgYnV0dG9uIGlzIEFDIG9yIERFTCwgdGhlbiB3ZSBuZWVkIHRvIHJlc2V0IG9yIHJld2luZCBvciBGU00gICAgICovXG4gICAgc3dpdGNoKGJ1dHRvbikge1xuICAgICAgY2FzZSAnQUMnOlxuICAgICAgICAvKiBJZiB0aGUgYnV0dG9uIGlzIEFDLCB3ZSBjb21wbGV0ZWx5IHJlc2V0IHRoZSBGU00uIFRoZSBuZXh0IHN0YXR1cyBpc1xuICAgICAgICAgKiBkaWdpdCBvbmx5LCBhbmQgdGhlIGZvcm11bGEgYW5kIHJlc3VsdCBhcmUgY2xlYXJlZCAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBESUdJVFxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Zvcm11bGE6ICcnLCByZXN1bHQ6ICcnfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ0RFTCc6XG4gICAgICAgIC8qIElmIHRoZSBERUwgYnV0dG9uIGlzIHByZXNzZWQsIHRoZW4gd2UgcmVtb3ZlIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGVcbiAgICAgICAgICogZm9ybXVsYSBhbmQgZ2V0IHRoZSBjb3JyZXNwb25kaW5nIHN0YXR1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgIGxldCBmb3JtdWxhID0gdGhpcy5zdGF0ZS5mb3JtdWxhXG4gICAgICAgIGZvcm11bGEgPSBmb3JtdWxhLnN1YnN0cigwLCBmb3JtdWxhLmxlbmd0aC0xKVxuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5nZXRQcmV2aW91c1N0YXR1cyhmb3JtdWxhKVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Zvcm11bGF9KVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogSWYgYW5vdGhlciBidXR0b24gaXMgcHJlc3NlZCwgdGhlbiB3ZSBjb21wdXRlIHRoZSBuZXh0IHN0YXR1cyAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0TmV4dFN0YXR1cyhidXR0b24pXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyogUmVuZGVyIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjYWxjdWxhdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4oXG4gICAgICA8Qm9keT5cbiAgICAgICAgey8qIENyZWF0ZSB0aGUgc2NyZWVuLCB3aGljaCB3aWxsIGhvbGQgdGhlIGN1cnJlbnQgZm9ybXVsYSBhbmQgcmVzdWx0ICovfVxuICAgICAgICA8U2NyZWVuPlxuICAgICAgICAgIHsvKiBBZGQgdGhlIGZvcm11bGEgdG8gdGhlIHNjcmVlbi4gQWRkIHNwYWNlcyBhcm91bmQgb3BlcmF0b3JzIGZvclxuICAgICAgICAgICAgKiBjbGFyaXR5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi99XG4gICAgICAgICAgPEZvcm11bGE+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuZm9ybXVsYS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8oLikoWysveC1dKS9nLFxuICAgICAgICAgICAgICAgIChlLG0xLG0yKSA9PiBtMSsnICcrbTIrJyAnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L0Zvcm11bGE+XG4gICAgICAgICAgey8qIEFkZCB0aGUgY3VycmVudCByZXN1bHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL31cbiAgICAgICAgICA8UmVzdWx0Pnt0aGlzLnN0YXRlLnJlc3VsdH08L1Jlc3VsdD5cbiAgICAgICAgPC9TY3JlZW4+XG5cbiAgICAgICAgey8qIEZpbGwgdGhlIGNhbGN1bGF0b3Igd2l0aCBpdHMgYnV0dG9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovfVxuXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmJ1dHRvbnMubWFwKChiKSA9PiA8QnV0dG9uIHsuLi5ifSBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uQnV0dG9uQ2xpY2soYi52YWx1ZSl9PntiLnZhbHVlfTwvQnV0dG9uPilcbiAgICAgICAgfVxuICAgICAgPC9Cb2R5PlxuICAgIClcbiAgfVxufVxuXG5cbi8qIFRoZSA8ZGl2IGlkPSdyb290Jz4gZWxlbWVudCBvZiBvdXIgSFRNTCB3aWxsIHJlbmRlciBvdXIgY29tcG9uZW50cyAgICAgICAgICovXG5sZXQgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKVxuXG4vKiBSZW5kZXIgdGhlIENhbGN1bGF0b3IgcHJvamVjdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuUmVhY3RET00ucmVuZGVyKDxDYWxjdWxhdG9yIC8+LCB0YXJnZXQpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2ZjYy9jYWxjdWxhdG9yL2luZGV4LmpzeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBV0E7QUFDQTs7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTs7Ozs7OztBQXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTs7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBREE7QUFnT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF1QkE7QUFDQTtBQXJQQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFiQTtBQXFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7OztBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVBBO0FBVUE7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVFQTtBQUNBO0FBOEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUEyQkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQUE7QUFKQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFaQTtBQWtCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFwQkE7QUF3QkE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48\n");

/***/ })

/******/ });